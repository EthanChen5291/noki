import random
from typing import Optional
from analysis.audio_analysis import (
    analyze_song_intensity, 
    get_sb_info, 
    group_info_by_section, 
    filter_sb_info
)
from . import constants as C
from . import models as M

# ==================== SLOT-BASED RHYTHM GENERATION ====================

def build_rhythm_slots(sb_info: list[M.SubBeatInfo], song: M.Song) -> list[M.RhythmSlot]:
    """
    Build rhythm slots from audio analysis.
    A slot is a potential character placement based on musical features.
    """
    slots: list[M.RhythmSlot] = []
    beat_duration = 60 / song.bpm
    
    for i, sb in enumerate(sb_info):
        is_note_slot = False
        priority = 0
        
        if sb.level == M.SubBeatIntensity.STRONG:
            is_note_slot = True
            priority = 3  # high priority
        elif sb.level == M.SubBeatIntensity.MEDIUM:
            is_note_slot = True
            priority = 2  # medium priority
        else:
            # weak (only use if needed for rhythm variety)
            if i > 0 and slots and (sb.time - slots[-1].time) > 0.4:
                # fill long gaps with weak beats
                is_note_slot = True
                priority = 1
        
        if is_note_slot:
            slots.append(M.RhythmSlot(
                time=sb.time,
                intensity=sb.raw_intensity,
                priority=priority,
                is_filled=False,
                beat_position=sb.time / beat_duration
            ))
    
    return slots


def filter_slots_for_playability(slots: list[M.RhythmSlot], min_spacing: float = 0.12) -> list[M.RhythmSlot]:
    """
    Remove slots that are too close together for comfortable typing.
    Modern rhythm games maintain ~120-150ms minimum spacing.
    """
    if not slots:
        return []
    
    filtered = [slots[0]]
    
    for slot in slots[1:]:
        if slot.time - filtered[-1].time >= min_spacing:
            filtered.append(slot)
    
    return filtered


def group_slots_by_measure(slots: list[M.RhythmSlot], beat_duration: float) -> list[list[M.RhythmSlot]]:
    """Group rhythm slots into measures (4 beats each)"""
    if not slots:
        return []
    
    measure_duration = beat_duration * C.BEATS_PER_MEASURE
    
    first_measure = int(slots[0].time / measure_duration)
    last_measure = int(slots[-1].time / measure_duration)
    
    num_measures = last_measure - first_measure + 1
    measures: list[list[M.RhythmSlot]] = [[] for _ in range(num_measures)]
    
    for slot in slots:
        measure_idx = int(slot.time / measure_duration) - first_measure
        if 0 <= measure_idx < num_measures:
            measures[measure_idx].append(slot)
    
    # measures = [m for m in measures if m]  # uncomment to remove empty measures
    
    return measures


# ==================== SMART WORD ASSIGNMENT ====================

def get_words_with_rhythm_info(words: list[str], beat_duration: float) -> list[M.Word]:
    """Enhanced word creation with better rhythm properties"""
    return [
        M.Word(
            text=word,
            rest_type=None,
            ideal_beats=(ideal := len(word) / C.TARGET_CPS / beat_duration),
            snapped_beats=(snapped := snap_to_grid(ideal, C.SNAP_GRID)),
            snapped_cps=len(word) / (snapped * beat_duration)
        )
        for word in words
    ]


def select_word_for_measure(
    available_slots: int,
    remaining_words: list[M.Word],
    word_bank: list[M.Word],
    intensity_ratio: float = 1.0
) -> Optional[M.Word]:
    """
    Select the best word for a measure based on:
    - Number of available rhythm slots
    - Intensity ratio (loud = more chars, quiet = fewer)
    - Word variety
    """
    if not remaining_words:
        return None
    
    # adjust target based on intensity
    if intensity_ratio > 1.2:
        target_chars = min(available_slots, int(available_slots * 0.9))
    elif intensity_ratio > 1.0:
        target_chars = min(available_slots, int(available_slots * 0.8))
    elif intensity_ratio < 0.8:
        target_chars = max(2, int(available_slots * 0.5))
    elif intensity_ratio < 1.0:
        target_chars = max(2, int(available_slots * 0.7))
    else:
        target_chars = max(2, int(available_slots * 0.75))
    
    # Find words matching target length with tolerance, but MUST fit in available slots
    tolerance = 2 if abs(intensity_ratio - 1.0) > 0.3 else 1
    candidates = [
        w for w in remaining_words
        if abs(len(w.text) - target_chars) <= tolerance and len(w.text) <= available_slots
    ]

    if not candidates:
        candidates = [w for w in remaining_words if len(w.text) <= available_slots]

    if not candidates:
        # Last resort: pick shortest word even if longer than slots (will be truncated)
        candidates = [min(remaining_words, key=lambda w: len(w.text))]
    
    target_cps = C.TARGET_CPS * intensity_ratio
    viable = [w for w in candidates if abs(w.snapped_cps - target_cps) <= C.CPS_TOLERANCE * 1.5]
    
    return random.choice(viable if viable else candidates)


# ==================== SLOT ASSIGNMENT ====================

def find_next_measure_time(measures, start_idx, fallback_time):
    for j in range(start_idx + 1, len(measures)):
        if measures[j]:  # non-empty measure
            return measures[j][0].time
    return fallback_time

def assign_words_to_slots(
    measures: list[list[M.RhythmSlot]],
    word_bank: list[M.Word],
    beat_duration: float,
    intensity_profile: Optional[M.IntensityProfile] = None,
    dual_side_sections: Optional[list[M.DualSideSection]] = None
) -> list[M.CharEvent]:
    """
    Assign characters to rhythm slots measure-by-measure.
    This creates a natural, musical rhythm flow.
    """
    events: list[M.CharEvent] = []
    remaining_words = word_bank.copy()
    section_idx = 0
    last_word_end_time = -float('inf')
    last_word_text = ""

    # Grace period at start of dual sections: 1 measure (4 beats) of rest
    grace_beats = 4
    grace_duration = grace_beats * beat_duration

    for measure_idx, measure_slots in enumerate(measures):
        if not measure_slots or not remaining_words:
            continue

        section_idx = measure_idx // 4

        first_slot_time = measure_slots[0].time
        if first_slot_time < last_word_end_time + C.MIN_WORD_GAP:
            continue

        # Skip entire measures that fall within grace periods of a dual section
        # (both at start AND at end of dual sections)
        in_grace_period = False
        if dual_side_sections:
            for dual_sec in dual_side_sections:
                # Start grace period: first 4 beats of dual section
                start_grace_end = dual_sec.start_time + grace_duration
                if dual_sec.start_time <= first_slot_time < start_grace_end:
                    in_grace_period = True
                    break
                # End grace period: 4 beats after dual section ends
                end_grace_end = dual_sec.end_time + grace_duration
                if dual_sec.end_time <= first_slot_time < end_grace_end:
                    in_grace_period = True
                    break

        if in_grace_period:
            continue

        intensity_ratio = 1.0
        if intensity_profile and section_idx < len(intensity_profile.section_intensities):
            avg_intensity = sum(intensity_profile.section_intensities) / len(intensity_profile.section_intensities)
            intensity_ratio = intensity_profile.section_intensities[section_idx] / (avg_intensity + 1e-6)

        if intensity_profile and section_idx < len(intensity_profile.section_intensities):
            intensity = intensity_profile.section_intensities[section_idx]
            avg = sum(intensity_profile.section_intensities) / len(intensity_profile.section_intensities)

            if intensity < avg * 0.6 and random.random() < 0.5:
                continue

        candidates = [w for w in remaining_words if w.text != last_word_text]
        if not candidates:
            candidates = remaining_words

        word = select_word_for_measure(
            len(measure_slots),
            candidates,
            word_bank,
            intensity_ratio
        )

        if not word or not word.text:
            continue

        if word in remaining_words:
            remaining_words.remove(word)

        chars_to_place = min(len(word.text), len(measure_slots), C.MAX_SLOTS_PER_MEASURE)

        sorted_slots = sorted(measure_slots, key=lambda s: s.priority, reverse=True)
        selected_slots = sorted_slots[:chars_to_place]

        selected_slots.sort(key=lambda s: s.time)

        if not selected_slots:
            continue

        for char_idx in range(chars_to_place):
            char = word.text[char_idx]
            slot = selected_slots[char_idx]

            # Check if this note is in a dual-side section
            from_left = False
            if dual_side_sections:
                for dual_sec in dual_side_sections:
                    if dual_sec.start_time <= slot.time < dual_sec.end_time:
                        # Alternate sides based on character index within word
                        from_left = (char_idx % 2 == 1)
                        break

            events.append(M.CharEvent(
                char=char,
                timestamp=slot.time,
                word_text=word.text,
                char_idx=char_idx,
                beat_position=slot.beat_position,
                section=section_idx,
                is_rest=False,
                from_left=from_left
            ))
            slot.is_filled = True

        last_word_end_time = selected_slots[chars_to_place - 1].time
        last_word_text = word.text

        if measure_idx < len(measures) - 1:
            rest_time = selected_slots[-1].time + 0.1

            events.append(M.CharEvent(
                char="",
                timestamp=rest_time,
                word_text="",
                char_idx=-1,
                beat_position=selected_slots[-1].beat_position,
                section=section_idx,
                is_rest=True
            ))

        # recycle words if running low
        if len(remaining_words) < len(word_bank) * 0.3:
            for w in word_bank:
                if w not in remaining_words:
                    remaining_words.append(w)

    return events


# ==================== RHYTHM VARIATIONS ====================

def add_rhythm_variations(events: list[M.CharEvent], song: M.Song) -> list[M.CharEvent]:
    """
    Add modern rhythm game elements:
    - Occasional bursts (fast typing sections)
    - Syncopation (off-beat emphasis)
    - Call-and-response patterns
    """
    if not events:
        return events
    
    sections = group_events_by_section(events)
    enhanced: list[M.CharEvent] = []
    
    for section in sections:
        # 20% chance for BURST which is slightly more intense
        if random.random() < 0.2:
            for e in section:
                if not e.is_rest:
                    e_copy = M.CharEvent(
                        char=e.char,
                        timestamp=e.timestamp * 0.95,  # 5% faster
                        word_text=e.word_text,
                        char_idx=e.char_idx,
                        beat_position=e.beat_position,
                        section=e.section,
                        is_rest=e.is_rest
                    )
                    enhanced.append(e_copy)
                else:
                    enhanced.append(e)
        else:
            enhanced.extend(section)
    
    return enhanced


# ==================== UTILITY FUNCTIONS ====================

def snap_to_grid(beats: float, grid: float = 0.5) -> float:
    """Snap beats to nearest musical grid interval"""
    return round(beats / grid) * grid


def group_events_by_section(events: list[M.CharEvent]) -> list[list[M.CharEvent]]:
    """Groups CharEvents by section"""
    if not events:
        return []
    
    sections: list[list[M.CharEvent]] = []
    current = [events[0]]
    
    for e in events[1:]:
        if e.section != current[-1].section:
            sections.append(current)
            current = []
        current.append(e)
    
    if current:
        sections.append(current)
    
    return sections

def adjust_slots_by_intensity(
    measures: list[list[M.RhythmSlot]], 
    intensity_profile: Optional[M.IntensityProfile],
    beat_duration: float
) -> list[list[M.RhythmSlot]]:
    """
    Adjust slot density based on song intensity.
    Loud sections = more slots (higher CPS)
    Quiet sections = fewer slots (lower CPS)
    """
    if not intensity_profile or not measures:
        return measures
    
    adjusted_measures = []
    
    for measure_idx, measure_slots in enumerate(measures):
        if not measure_slots:
            adjusted_measures.append([])
            continue
        
        section_idx = measure_idx // 4
        
        if section_idx >= len(intensity_profile.section_intensities):
            adjusted_measures.append(measure_slots)
            continue
        
        section_intensity = intensity_profile.section_intensities[section_idx]
        avg_intensity = sum(intensity_profile.section_intensities) / len(intensity_profile.section_intensities)
        intensity_ratio = section_intensity / (avg_intensity + 1e-6)
        
        # ADJUST SLOT DENSITY BASED ON INTENSITY
        if intensity_ratio > 1.3:  # very loud
            keep_slots = [s for s in measure_slots if s.priority >= 2]
            target_cps = C.TARGET_CPS * 1.2  # 20% faster
        elif intensity_ratio > 1.1:  # moderately loud
            keep_slots = [s for s in measure_slots if s.priority >= 3]
            target_cps = C.TARGET_CPS * 1.1  # 10% faster
        elif intensity_ratio < 0.7:  # quiet section
            keep_slots = sorted(measure_slots, key=lambda s: s.priority, reverse=True)
            keep_slots = keep_slots[:max(2, len(measure_slots) // 2)]
            target_cps = C.TARGET_CPS * 0.8  # 20% slower
        elif intensity_ratio < 0.9:  # slightly quiet
            keep_slots = [s for s in measure_slots if s.priority >= 3]
            target_cps = C.TARGET_CPS * 0.9  # 10% slower
        else:
            keep_slots = measure_slots
            target_cps = C.TARGET_CPS
        
        if len(keep_slots) > 1:
            keep_slots.sort(key=lambda s: s.time)
            filtered = [keep_slots[0]]
            
            for slot in keep_slots[1:]:
                if slot.time - filtered[-1].time >= 0.12:
                    filtered.append(slot)
            
            adjusted_measures.append(filtered)
        else:
            adjusted_measures.append(keep_slots)
    
    return adjusted_measures

# ==================== MAIN GENERATION ====================

def generate_beatmap(
    word_list: list[str],
    song: M.Song,
    dual_side_sections: Optional[list[M.DualSideSection]] = None
) -> list[M.CharEvent]:
    """Generate an engaging, playable beatmap using slot-based rhythm generation."""
    beat_duration = 60 / song.bpm

    sb_info = get_sb_info(song, subdivisions=4)
    slots = build_rhythm_slots(sb_info, song)
    slots = filter_slots_for_playability(slots, min_spacing=0.12)

    measures = group_slots_by_measure(slots, beat_duration)

    intensity_profile = None
    if song.file_path:
        path = C._to_abs_path(song.file_path)
        if path:
            intensity_profile = analyze_song_intensity(path, song.bpm)

    # adjust slots based on intensity
    measures = adjust_slots_by_intensity(measures, intensity_profile, beat_duration)

    for i, measure in enumerate(measures):
        if len(measure) > C.MAX_SLOTS_PER_MEASURE:

            measure_sorted = sorted(measure, key=lambda s: (-s.priority, s.time))
            measures[i] = sorted(measure_sorted[:C.MAX_SLOTS_PER_MEASURE], key=lambda s: s.time)

    word_bank = get_words_with_rhythm_info(word_list, beat_duration)
    events = assign_words_to_slots(measures, word_bank, beat_duration, intensity_profile, dual_side_sections)
    #events = add_rhythm_variations(events, song)

    events = deduplicate_events(events, beat_duration, min_spacing=0.1)

    return events


def deduplicate_events(
    events: list[M.CharEvent],
    beat_duration: float,
    min_spacing: float = 0.1
) -> list[M.CharEvent]:
    """
    Remove events that are too close together and cap events per measure.
    This catches any duplicates created during processing.
    """
    if not events:
        return events

    events = sorted(events, key=lambda e: e.timestamp)

    filtered: list[M.CharEvent] = []
    for event in events:
        if event.is_rest:
            filtered.append(event)
            continue

        last_char_event = None
        for e in reversed(filtered):
            if not e.is_rest:
                last_char_event = e
                break

        if last_char_event is None or (event.timestamp - last_char_event.timestamp) >= min_spacing:
            filtered.append(event)

    measure_duration = beat_duration * C.BEATS_PER_MEASURE
    measure_events: dict[int, list[M.CharEvent]] = {}

    for event in filtered:
        if event.is_rest:
            continue
        measure_idx = int(event.timestamp / measure_duration)
        if measure_idx not in measure_events:
            measure_events[measure_idx] = []
        measure_events[measure_idx].append(event)

    events_to_remove: set[float] = set()
    for measure_idx, m_events in measure_events.items():
        if len(m_events) > C.MAX_SLOTS_PER_MEASURE:
            excess = m_events[C.MAX_SLOTS_PER_MEASURE:]
            for e in excess:
                events_to_remove.add(e.timestamp)

    final = [e for e in filtered if e.is_rest or e.timestamp not in events_to_remove]

    return final